# PostgreSQL Migration Guide

This project currently uses SQLite through `app/db.py`. This document outlines how to migrate to PostgreSQL while keeping the codebase portable.

## 1) Dependencies and configuration
- Add a PostgreSQL driver (recommended: `psycopg` or `psycopg2-binary`) to `requirements.txt`.
- Set `DATABASE_URL` to a Postgres URI, for example: `postgresql://user:password@localhost:5432/north_star`.
- Keep `DATABASE_URL` as the single source of truth for selecting the database.

## 2) Database connection layer
Update `app/db.py` to:
- Parse `DATABASE_URL` and branch between SQLite and Postgres.
- Use `psycopg.connect` (or equivalent) for Postgres connections.
- Replace SQLite-only logic (`PRAGMA table_info`, file paths) with portable metadata queries or migrations.

## 3) Schema creation and migrations
SQLite currently creates tables on startup and seeds data. For Postgres:
- Introduce a migration tool (recommended: Alembic) to manage schema changes.
- Create migrations for `projects` and `items` tables with the same columns.
- Move seed data logic into a separate initialization script (e.g., `python -m app.db.seed`) that can be run intentionally.

## 4) SQL portability checklist
Keep SQL portable and avoid SQLite-specific behavior:
- Use `INTEGER` and `TEXT` types that map cleanly to Postgres.
- Replace `AUTOINCREMENT` with `SERIAL` or `GENERATED BY DEFAULT AS IDENTITY`.
- Avoid relying on SQLite’s permissive typing or implicit conversions.
- Ensure `created_at` uses ISO timestamps consistently (or use `TIMESTAMPTZ` in Postgres).

## 5) Data migration approach
For a one-time migration from SQLite to Postgres:
1. Export SQLite data to CSV (one file per table).
2. Create the Postgres schema via migrations.
3. Import CSVs into Postgres with `COPY`.
4. Validate counts and spot-check data integrity.

If you want a scripted path, write a small Python migration tool that reads from SQLite and writes to Postgres using parameterized inserts.

## 6) Application changes to consider
- Update error messaging: remove the “Only sqlite is supported” guard.
- Add connection pooling for Postgres if traffic grows.
- Ensure `update_item`/`delete_item` behaviors are unchanged across backends.

## 7) Verification checklist
- Start the server with a Postgres `DATABASE_URL`.
- Confirm schema exists and seed data runs only when intended.
- Run API calls for list/get/add/edit/delete items and progress/objective updates.
- Verify UI behavior for project selection and item edits.

## 8) Rollback strategy
Keep SQLite support behind a configuration flag until Postgres is proven in staging. If needed:
- Switch `DATABASE_URL` back to SQLite.
- Re-run the app without schema changes or seeds on startup.
